<html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>使用 MailOtto 做预加载</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@drak11t" /><meta name="twitter:title" content="使用 MailOtto 做预加载" /><meta name="twitter:description" content="最近我开源了一个专注懒事件的事件总线 MailOtto: https://github.com/drakeet/MailOtto 并写了一个用它来做预加载的实践案例：第一个页面预先为第四个页面发起数据加载请求，等用户进入第四个页面，那加载好的数据才会分发给它，若在数据下来前进入第四个页面，也会等完成的时候自动接收到。"><meta name="description" content="最近我开源了一个专注懒事件的事件总线 MailOtto: https://github.com/drakeet/MailOtto 并写了一个用它来做预加载的实践案例：第一个页面预先为第四个页面发起数据加载请求，等用户进入第四个页面，那加载好的数据才会分发给它，若在数据下来前进入第四个页面，也会等完成的时候自动接收到。"><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/gravatar.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/mailotto-sample"><link rel="alternate" type="application/atom+xml" title="Black history of Drakeet" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img class="gravatar" width="80px" height="80px" src="/assets/gravatar.png"> </a> <span class="logo-prompt">返回</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>使用 MailOtto 做预加载</h1><time>4 17, 2016</time></div><div class="divider"></div><p>最近我开源了一个专注懒事件的事件总线 <strong>MailOtto</strong>: <a href="https://github.com/drakeet/MailOtto" target="_blank">https://github.com/drakeet/MailOtto</a> 并写了一个用它来做预加载的实践案例：第一个页面预先为第四个页面发起数据加载请求，等用户进入第四个页面，那加载好的数据才会分发给它，若在数据下来前进入第四个页面，也会等完成的时候自动接收到。</p><p>这个数据需要 8 秒，如果进入到第四个页面才开始加载，体验就很不好，就算只要 1 秒，也会有一个文本从无到有闪动的过程。如果在第一个页面停留超过 8 秒，它足够完成全程预加载，进入第四个页面里面就能直接拿到数据，可谓完美预加载。</p><p>本文就是来介绍一下这个实践案例。</p><p>先上这个实践的源码，它位于 <strong>MailOtto</strong> 下的 sample 模块：<a href="https://github.com/drakeet/MailOtto/tree/master/sample/src/main/java/me/drakeet/mailotto/demo" target="_blank">sample</a>, 演示 apk <a href="https://github.com/drakeet/MailOtto/releases" target="_blank">下载</a></p><p>MainActivity 作为模拟一个用户可能停留比较长时间的页面，这样我们就可以在这个页面背后进行为后续的某个页面内容做预加载。</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPreload</span><span class="p">(</span><span class="kd">final</span> <span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">((</span><span class="n">TextView</span><span class="o">)</span><span class="n">view</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">": loading..."</span><span class="o">);</span>
    <span class="n">mHandler</span><span class="o">.</span><span class="na">postDelayed</span><span class="o">(</span><span class="k">new</span> <span class="n">InnerRunnable</span><span class="o">(</span><span class="n">view</span><span class="o">),</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>以上代码模拟了一个耗时 8 * 1000 毫秒的后台任务，为了避免 Runnable 匿名内部类引用 MainActivity.this 造成内存泄漏，我使用了一个 InnerRunnable 静态内部类：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">InnerRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

    <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">TextView</span><span class="o">&gt;</span> <span class="n">textViewPreference</span><span class="o">;</span>


    <span class="kd">public</span> <span class="n">InnerRunnable</span><span class="o">(</span><span class="n">View</span> <span class="n">textView</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">textViewPreference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;&gt;((</span><span class="n">TextView</span><span class="o">)</span> <span class="n">textView</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">textViewPreference</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">textViewPreference</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="s">": done!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">Mailbox</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="k">new</span> <span class="n">Mail</span><span class="o">(</span><span class="s">"A mail from MainActivity"</span><span class="o">,</span> <span class="n">TargetActivity</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在这个静态内部类中，run 方法会在 8s 后被调用，从而将加载下来的数据交给 <strong>Mailbox “邮递员”</strong>。</p><p>之后路过两个无谓的 NextActivity：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="n">startActivity</span><span class="o">(</span><span class="n">NextActivity</span><span class="o">.</span><span class="na">getIntent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="cm">/*page = */</span><span class="mi">2</span><span class="o">));</span>
</code></pre></div><p>这两个页面基本什么都没干，纯粹是为了演示跨页面懒通讯，为什么要演示这个内容呢，因为这是为了体现 <strong>MailOtto</strong> 在<strong>跨页面运输</strong>方面天生比 Intent 方式容易得多，而且它支持懒发送懒接收。</p><p>到进入第四个页面，即 <strong>TargetActivity</strong>，我们只要告诉“邮递员”：我在家，送信给我吧！“邮递员”就会自动调用你的 <strong>@OnMailReceived</strong>:</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="n">Mailbox</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">atHome</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@OnMailReceived</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">onPreloadDataReady</span><span class="o">(</span><span class="n">Mail</span> <span class="n">mail</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mTextView</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">mail</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div><p>这时候那加载好的数据才会分发给 TargetActivity，若在数据下来前进入 TargetActivity，也会等完成的时候自动接收到。所以我们不必再进行一堆判断或重新请求。</p><p>另外，为了防止单例造成内存泄漏，需要在页面结束的时候应该对 Mailbox 标示 “我已经离开了”：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="n">Mailbox</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">leave</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</code></pre></div><p>到此为止，我的例子就结束了。当然这个库绝不仅限于做预加载，只是今天突然发现它天生地适合做预加载，另外它也可以用于取代 <strong>startActivityForResult</strong>，同时拥有 Otto/EventBus 的功能。</p></article></main></body></html>