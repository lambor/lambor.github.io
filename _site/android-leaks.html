<html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Android 内存泄漏案例和解析</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@drak11t" /><meta name="twitter:title" content="Android 内存泄漏案例和解析" /><meta name="twitter:description" content="Android 编程所使用的 Java 是一门使用垃圾收集器（GC, garbage collection）来自动管理内存的语言，它使得我们不再需要手动调用代码来进行内存回收。那么它是如何判断的呢？简单说，如果一个对象，从它的根节点开始不可达的话，那么这个对象就是没有引用的了，是会被垃圾收集器回收的，其中，所谓的 “根节点” 往往是一个线程，比如主线程。因此，如果一个对象从它的根节点开始是可..."><meta name="description" content="Android 编程所使用的 Java 是一门使用垃圾收集器（GC, garbage collection）来自动管理内存的语言，它使得我们不再需要手动调用代码来进行内存回收。那么它是如何判断的呢？简单说，如果一个对象，从它的根节点开始不可达的话，那么这个对象就是没有引用的了，是会被垃圾收集器回收的，其中，所谓的..."><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/gravatar.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/android-leaks"><link rel="alternate" type="application/atom+xml" title="Black history of Drakeet" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img class="gravatar" width="80px" height="80px" src="/assets/gravatar.png"> </a> <span class="logo-prompt">返回</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Android 内存泄漏案例和解析</h1><time>3 15, 2016</time></div><div class="divider"></div><p>Android 编程所使用的 Java 是一门使用垃圾收集器（GC, garbage collection）来自动管理内存的语言，它使得我们不再需要手动调用代码来进行内存回收。那么它是如何判断的呢？简单说，如果一个对象，从它的根节点开始不可达的话，那么这个对象就是没有引用的了，是会被垃圾收集器回收的，其中，所谓的 “根节点” 往往是一个线程，比如主线程。因此，<strong>如果一个对象从它的根节点开始是可达的有引用的，但实际上它已经没有再使用了，是无用的，这样的对象就是内存泄漏的对象</strong>，它会在内存中占据我们应用程序原本就不是很多的内存，导致程序变慢，甚至内存溢出（OOM）程序崩溃。</p><p>内存泄漏的原因并不难理解，但仅管知道它的存在，往往我们还是会不知觉中写出致使内存泄漏的代码。在 Android 编程中，也是有许多情景容易导致内存泄漏，以下将一一列举一些我所知道的内存泄漏案例，从这些例子中应该能更加直观了解怎么导致了内存泄漏，从而在编程过程中去避免。</p><h4>静态变量造成内存泄漏</h4><p>首先，比较简单的一种情况是，静态变量致使内存泄漏，说到静态变量，我们至少得了解其生命周期才能彻底明白。静态变量的生命周期，起始于类的加载，终止于类的释放。对于 Android 而言，程序也是从一个 main 方法进入，开始了主线程的工作，如果一个类在主线程或旁枝中被使用到，它就会被加载，反过来说，假如一个类存在于我们的项目中，但它从未被我们使用过，算是个孤岛，这时它是没有被加载的。一旦被加载，只有等到我们的 Android 应用进程结束它才会被卸载。</p><p>于是，当我们在 Activity 中声明一个静态变量引用了 Activity 自身，就会造成内存泄漏：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeakActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Context</span> <span class="n">sContext</span><span class="o">;</span>


    <span class="nd">@Override</span> <span class="kd">protected</span> <span class="kt">void</span> <span class="n">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_leak</span><span class="o">);</span>
        <span class="n">sContext</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这样的代码会导致当这个 Activity 结束的时候，sContext 仍然持有它的引用，致使 Activity 无法回收。解决办法就是在这个 Activity 的 onDestroy 时将 sContext 的值置空，或者避免使用静态变量这样的写法。</p><p>同样的，如果一个 Activity 的静态 field 变量<strong>内部</strong>获得了当前 Activity 的引用，比如我们经常会把 this 传给 View 之类的对象，这个对象若是静态的，并且没有在 Activity 生命周期结束之前置空的话，也会导致同样的问题。</p><h4>非静态内部类和匿名内部类造成内存泄漏</h4><p>也是一个很常见的情景，经常会遇到的 Handler 问题就是这样一种情况，如果我们在 field 声明一个 Handler 变量：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
</code></pre></div><p>由于在 Java 中，<strong>非静态内部类（包括匿名内部类，比如这个 Handler 匿名内部类）会引用外部类对象 this（比如 Activity），而静态的内部类则不会引用外部类对象。</strong>所以这里 Handler 会引用 Activity 对象，当它使用了 postDelayed 的时候，如果 Activity 已经 finish 了，而这个 handler 仍然引用着这个 Activity 就会致使内存泄漏，因为<strong>这个 handler 会在一段时间内继续被 main Looper 持有，导致引用仍然存在</strong>，在这段时间内，如果内存吃紧至超出，就很危险了。</p><p>解决办法就是大家都知道的使用<strong>静态内部类</strong>加 WeakReference：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">StaticHandler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StaticHandler</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">StaticHandler</span> <span class="kd">extends</span> <span class="n">Handler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Activity</span><span class="o">&gt;</span> <span class="n">mActivity</span><span class="o">;</span>


    <span class="kd">public</span> <span class="n">StaticHandler</span><span class="o">(</span><span class="n">Activity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mActivity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Activity</span><span class="o">&gt;(</span><span class="n">activity</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>另外，综合上面两种情况，如果一个变量，既是静态变量，而且是<strong>非静态的内部类对象，</strong>那么也会造成内存泄漏：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeakActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Hello</span> <span class="n">sHello</span><span class="o">;</span>


    <span class="nd">@Override</span> <span class="kd">protected</span> <span class="kt">void</span> <span class="n">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_leak</span><span class="o">);</span>

        <span class="n">sHello</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hello</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div><p>注意，这里我们定义的 Hello 虽然是空的，但它是一个非静态的内部类，所以它必然会持有外部类即 LeakActivity.this 引用，导致 sHello 这个静态变量一直持有这个 Activity，于是结果就和第一个例子一样，Activity 无法被回收。</p><p>到这里大家应该可以看出，内存泄漏经常和静态变量有关。和静态变量有关的，还有一种常见情景，就是使用<strong>单例模式没有解绑致使内存泄漏</strong>，单例模式的对象经常是和我们的应用相同的生命周期，如果我们使用 EventBus 或 Otto 并生成单例，注册了一个 Activity 而没有在页面结束的时候进行解除注册，那么单例会一直持有我们的 Activity，这个 Activity 虽然没有使用了，但会一直占用着内存。</p><h4>属性动画造成内存泄漏</h4><p>另外当我们使用属性动画，我们需要调用一些方法将动画停止，特别是无限循环的动画，否则也会造成内存泄漏，好在使用 View 动画并不会出现内存泄漏，估计 View 内部有进行释放和停止。</p><h4>RxJava 使用不当造成内存泄漏</h4><p>最后说一说 RxJava 使用不当造成的内存泄漏，RxJava 是一个非常易用且优雅的异步操作库。对于异步的操作，如果没有及时取消订阅，就会造成内存泄漏：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>
          <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">Action1</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
              <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">call</span><span class="o">(</span><span class="n">Long</span> <span class="n">aLong</span><span class="o">)</span> <span class="o">{</span>
                  <span class="c1">// pass</span>
              <span class="o">}</span>
          <span class="o">});</span>
</code></pre></div><p>同样是匿名内部类造成的引用没法被释放，使得如果在 Activity 中使用就会导致它无法被回收，即使我们的 Action1 看起来什么也没有做。解决办法就是接收 subscribe 返回的 Subscription 对象，在 Activity onDestroy 的时候将其取消订阅即可：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeakActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Subscription</span> <span class="n">mSubscription</span><span class="o">;</span>


    <span class="nd">@Override</span> <span class="kd">protected</span> <span class="kt">void</span> <span class="n">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_leak</span><span class="o">);</span>

        <span class="n">mSubscription</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">Action1</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
              <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="n">call</span><span class="o">(</span><span class="n">Long</span> <span class="n">aLong</span><span class="o">)</span> <span class="o">{</span>
                  <span class="c1">// pass</span>
              <span class="o">}</span>
            <span class="o">});</span>
    <span class="o">}</span>


    <span class="nd">@Override</span> <span class="kd">protected</span> <span class="kt">void</span> <span class="n">onDestroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
        <span class="n">mSubscription</span><span class="o">.</span><span class="na">unsubscribe</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>除了以上这种解决方式之外，还有一种解决方式就是通过 RxJava 的 compose 操作符和 Activity 的生命周期挂钩，我们可以使用一个很方便的第三方库叫做 <a href="https://github.com/trello/RxLifecycle" target="_blank">RxLifecycle</a> 来快捷做到这点，使用起来就像这样：</p><div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActivity</span> <span class="kd">extends</span> <span class="n">RxActivity</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">onResume</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onResume</span><span class="o">();</span>
        <span class="n">myObservable</span>
            <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="n">bindToLifecycle</span><span class="o">())</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>另外，它还提供了和 View 的便捷绑定，详情可以点击我提供的链接进行了解，这里不多说了。</p><p>总结来说，仍然是前面说的内部类或匿名内部类引用了外部类造成了内存泄漏，所以在实际编程过程中，如果涉及此类问题或者线程操作的，应该特别小心，很可能不知不觉中就写出了带内存泄漏的代码了。</p><h4>内存泄漏的检测</h4><p>前面说了不少内存泄漏的场景和对应的解决办法，但如果我们不知不觉中写出了带有内存泄漏隐患的代码怎么办，面对这个问题，其实到现在，我们是很幸运的，因为有很多相关的检查方式或组件可以选择，比如最简单的：观察 Memory Monitor 内存走势图，可以或多或少知道内存情况，但如果要精确地追踪到内存泄漏点，这里特别推荐伟大的 Square 公司开源的 <a href="https://github.com/square/leakcanary" target="_blank">LeakCanary</a> 方案，LeakCanary 可以做到非常简单方便、低侵入性地捕获内存泄漏代码，甚至很多时候你可以捕捉到 Android 官方组件的内存泄漏代码，具体使用大家可以自行参看其说明，由于本文主要想讲的是内存泄漏的原因和一些常见场景，对于检测，这里就不多说啦 ;)</p><p><img class="aligncenter" src="https://github.com/square/leakcanary/raw/master/assets/screenshot.png" alt="" width="364" height="189" /></p><p>相关资料：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank">https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/</a></li><li><a href="http://item.jd.com/11760209.html" target="_blank">Android 开发艺术探索</a></li></ul></article></main></body></html>